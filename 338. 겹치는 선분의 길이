def solution(lines):
    answer = 0
    list_len = []
    [[s1,e1],[s2,e2],[s3,e3]]=lines
    start=[s1,s2,s3]
    end=[e1,e2,e3]
    max_len=max(end)-min(start)
    for i in range(len(lines)):
        for j in range(i+1,len(lines)) :
            if lines[i][0]>=lines[j][0]:
                lines[i],lines[j]=lines[j],lines[i] # 시작점 작은순서대로 배열
    for k in range(len(lines)):
        for l in range(k+1,len(lines)):
            if lines[k][1]>=lines[l][0]:
                if lines[k][1]<=lines[l][1]:
                    list_len.append(lines[k][1]-lines[l][0])
                elif lines[k][1] > lines[l][1]:
                    list_len.append(lines[l][1]-lines[l][0])
    if lines[0][1]>=lines[2][0] :
        line_4=[lines[2][0],lines[0][1]]
        if lines[1][0]>=lines[2][0] and lines[1][1]<=lines[0][1]:
            list_len.append((lines[1][0]-lines[1][1])*2)
        elif lines[1][0]>=lines[2][0] and lines[1][1]>lines[0][1]:
            list_len.append((lines[1][0]-lines[0][1])*2)
        elif lines[1][0]<lines[2][0] and lines[1][1]<=lines[0][1]:
            list_len.append((lines[2][0]-lines[1][1])*2)
        else :
            list_len.append((lines[2][0]-lines[0][1])*2)
    print(list_len)        
    print(max_len)        
    answer = sum(list_len)    
    
    return answer

#이렇게 적어봤는데 오류가 발생했다. 가독성도 떨어지고 모든 경우의 수를 내가 직접 입력하려고 해서 문제인 것 같다.

#결국 gpt의 도움을 받아서 작성해 보았다.
def solution(lines):
    # 두 선분의 겹치는 구간 계산 함수
    def get_overlap(line1, line2):
        start1, end1 = line1
        start2, end2 = line2
        overlap_start = max(start1, start2)
        overlap_end = min(end1, end2)
        return max(0, overlap_end - overlap_start)

    # 세 선분의 겹치는 구간 계산 함수
    def get_triple_overlap(line1, line2, line3):
        start1, end1 = line1
        start2, end2 = line2
        start3, end3 = line3
        overlap_start = max(start1, start2, start3)
        overlap_end = min(end1, end2, end3)
        return max(0, overlap_end - overlap_start)

    # 2개씩의 선분에서 겹치는 구간 합산
    total_overlap = (
        get_overlap(lines[0], lines[1]) +
        get_overlap(lines[1], lines[2]) +
        get_overlap(lines[0], lines[2])
    )

    # 3개의 선분에서 공통 겹치는 구간 빼기
    triple_overlap = get_triple_overlap(lines[0], lines[1], lines[2])
    total_overlap -= 2 * triple_overlap

    return total_overlap
